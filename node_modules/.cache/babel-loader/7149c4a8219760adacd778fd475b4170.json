{"ast":null,"code":"'use strict';\n\nimport _slicedToArray from \"C:/Users/ASUS/Downloads/mini-project-master/mini-project-master/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport bind from './helpers/bind.js'; // utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\nvar getPrototypeOf = Object.getPrototypeOf;\n\nvar kindOf = function (cache) {\n  return function (thing) {\n    var str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n  };\n}(Object.create(null));\n\nvar kindOfTest = function kindOfTest(type) {\n  type = type.toLowerCase();\n  return function (thing) {\n    return kindOf(thing) === type;\n  };\n};\n\nvar typeOfTest = function typeOfTest(type) {\n  return function (thing) {\n    return typeof thing === type;\n  };\n};\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\n\n\nvar isArray = Array.isArray;\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\n\nvar isUndefined = typeOfTest('undefined');\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\n\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\n\n\nvar isArrayBuffer = kindOfTest('ArrayBuffer');\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\n\nfunction isArrayBufferView(val) {\n  var result;\n\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && isArrayBuffer(val.buffer);\n  }\n\n  return result;\n}\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\n\n\nvar isString = typeOfTest('string');\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\n\nvar isFunction = typeOfTest('function');\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\n\nvar isNumber = typeOfTest('number');\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\n\nvar isObject = function isObject(thing) {\n  return thing !== null && typeof thing === 'object';\n};\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\n\n\nvar isBoolean = function isBoolean(thing) {\n  return thing === true || thing === false;\n};\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\n\n\nvar isPlainObject = function isPlainObject(val) {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  var prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n};\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\n\n\nvar isDate = kindOfTest('Date');\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\n\nvar isFile = kindOfTest('File');\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\n\nvar isBlob = kindOfTest('Blob');\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\n\nvar isFileList = kindOfTest('FileList');\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\n\nvar isStream = function isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n};\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\n\n\nvar isFormData = function isFormData(thing) {\n  var kind;\n  return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' || // detect form-data instance\n  kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'));\n};\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\n\n\nvar isURLSearchParams = kindOfTest('URLSearchParams');\n\nvar _map = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest),\n    _map2 = _slicedToArray(_map, 4),\n    isReadableStream = _map2[0],\n    isRequest = _map2[1],\n    isResponse = _map2[2],\n    isHeaders = _map2[3];\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\n\n\nvar trim = function trim(str) {\n  return str.trim ? str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n};\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\n\n\nfunction forEach(obj, fn) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$allOwnKeys = _ref.allOwnKeys,\n      allOwnKeys = _ref$allOwnKeys === void 0 ? false : _ref$allOwnKeys;\n\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  var i;\n  var l; // Force an array if not already something iterable\n\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    var keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    var len = keys.length;\n    var key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  var keys = Object.keys(obj);\n  var i = keys.length;\n\n  var _key;\n\n  while (i-- > 0) {\n    _key = keys[i];\n\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n\n  return null;\n}\n\nvar _global = function () {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : typeof window !== 'undefined' ? window : global;\n}();\n\nvar isContextDefined = function isContextDefined(context) {\n  return !isUndefined(context) && context !== _global;\n};\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\n\n\nfunction\n  /* obj1, obj2, obj3, ... */\nmerge() {\n  var _ref2 = isContextDefined(this) && this || {},\n      caseless = _ref2.caseless;\n\n  var result = {};\n\n  var assignValue = function assignValue(val, key) {\n    var targetKey = caseless && findKey(result, key) || key;\n\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  };\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n\n  return result;\n}\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\n\n\nvar extend = function extend(a, b, thisArg) {\n  var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      allOwnKeys = _ref3.allOwnKeys;\n\n  forEach(b, function (val, key) {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {\n    allOwnKeys: allOwnKeys\n  });\n  return a;\n};\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\n\n\nvar stripBOM = function stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n\n  return content;\n};\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\n\n\nvar inherits = function inherits(constructor, superConstructor, props, descriptors) {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n};\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\n\n\nvar toFlatObject = function toFlatObject(sourceObj, destObj, filter, propFilter) {\n  var props;\n  var i;\n  var prop;\n  var merged = {};\n  destObj = destObj || {}; // eslint-disable-next-line no-eq-null,eqeqeq\n\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n\n    while (i-- > 0) {\n      prop = props[i];\n\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n};\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\n\n\nvar endsWith = function endsWith(str, searchString, position) {\n  str = String(str);\n\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n\n  position -= searchString.length;\n  var lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n};\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\n\n\nvar toArray = function toArray(thing) {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  var i = thing.length;\n  if (!isNumber(i)) return null;\n  var arr = new Array(i);\n\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n\n  return arr;\n};\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\n\n\nvar isTypedArray = function (TypedArray) {\n  // eslint-disable-next-line func-names\n  return function (thing) {\n    return TypedArray && thing instanceof TypedArray;\n  };\n}(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\n\n\nvar forEachEntry = function forEachEntry(obj, fn) {\n  var generator = obj && obj[Symbol.iterator];\n  var iterator = generator.call(obj);\n  var result;\n\n  while ((result = iterator.next()) && !result.done) {\n    var pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n};\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\n\n\nvar matchAll = function matchAll(regExp, str) {\n  var matches;\n  var arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n};\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\n\n\nvar isHTMLForm = kindOfTest('HTMLFormElement');\n\nvar toCamelCase = function toCamelCase(str) {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g, function replacer(m, p1, p2) {\n    return p1.toUpperCase() + p2;\n  });\n};\n/* Creating a function that will check if an object has a property. */\n\n\nvar hasOwnProperty = function (_ref4) {\n  var hasOwnProperty = _ref4.hasOwnProperty;\n  return function (obj, prop) {\n    return hasOwnProperty.call(obj, prop);\n  };\n}(Object.prototype);\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\n\n\nvar isRegExp = kindOfTest('RegExp');\n\nvar reduceDescriptors = function reduceDescriptors(obj, reducer) {\n  var descriptors = Object.getOwnPropertyDescriptors(obj);\n  var reducedDescriptors = {};\n  forEach(descriptors, function (descriptor, name) {\n    var ret;\n\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n  Object.defineProperties(obj, reducedDescriptors);\n};\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\n\nvar freezeMethods = function freezeMethods(obj) {\n  reduceDescriptors(obj, function (descriptor, name) {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    var value = obj[name];\n    if (!isFunction(value)) return;\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = function () {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n};\n\nvar toObjectSet = function toObjectSet(arrayOrString, delimiter) {\n  var obj = {};\n\n  var define = function define(arr) {\n    arr.forEach(function (value) {\n      obj[value] = true;\n    });\n  };\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n  return obj;\n};\n\nvar noop = function noop() {};\n\nvar toFiniteNumber = function toFiniteNumber(value, defaultValue) {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n};\n\nvar ALPHA = 'abcdefghijklmnopqrstuvwxyz';\nvar DIGIT = '0123456789';\nvar ALPHABET = {\n  DIGIT: DIGIT,\n  ALPHA: ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n};\n\nvar generateString = function generateString() {\n  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n  var alphabet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALPHABET.ALPHA_DIGIT;\n  var str = '';\n  var length = alphabet.length;\n\n  while (size--) {\n    str += alphabet[Math.random() * length | 0];\n  }\n\n  return str;\n};\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\n\n\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\n\nvar toJSONObject = function toJSONObject(obj) {\n  var stack = new Array(10);\n\n  var visit = function visit(source, i) {\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if (!('toJSON' in source)) {\n        stack[i] = source;\n        var target = isArray(source) ? [] : {};\n        forEach(source, function (value, key) {\n          var reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n        stack[i] = undefined;\n        return target;\n      }\n    }\n\n    return source;\n  };\n\n  return visit(obj, 0);\n};\n\nvar isAsyncFn = kindOfTest('AsyncFunction');\n\nvar isThenable = function isThenable(thing) {\n  return thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n};\n\nexport default {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isBoolean: isBoolean,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isReadableStream: isReadableStream,\n  isRequest: isRequest,\n  isResponse: isResponse,\n  isHeaders: isHeaders,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isRegExp: isRegExp,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isTypedArray: isTypedArray,\n  isFileList: isFileList,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM,\n  inherits: inherits,\n  toFlatObject: toFlatObject,\n  kindOf: kindOf,\n  kindOfTest: kindOfTest,\n  endsWith: endsWith,\n  toArray: toArray,\n  forEachEntry: forEachEntry,\n  matchAll: matchAll,\n  isHTMLForm: isHTMLForm,\n  hasOwnProperty: hasOwnProperty,\n  hasOwnProp: hasOwnProperty,\n  // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors: reduceDescriptors,\n  freezeMethods: freezeMethods,\n  toObjectSet: toObjectSet,\n  toCamelCase: toCamelCase,\n  noop: noop,\n  toFiniteNumber: toFiniteNumber,\n  findKey: findKey,\n  global: _global,\n  isContextDefined: isContextDefined,\n  ALPHABET: ALPHABET,\n  generateString: generateString,\n  isSpecCompliantForm: isSpecCompliantForm,\n  toJSONObject: toJSONObject,\n  isAsyncFn: isAsyncFn,\n  isThenable: isThenable\n};","map":{"version":3,"sources":["C:/Users/ASUS/Downloads/mini-project-master/mini-project-master/node_modules/axios/lib/utils.js"],"names":["bind","toString","Object","prototype","getPrototypeOf","kindOf","cache","thing","str","call","slice","toLowerCase","create","kindOfTest","type","typeOfTest","isArray","Array","isUndefined","isBuffer","val","constructor","isFunction","isArrayBuffer","isArrayBufferView","result","ArrayBuffer","isView","buffer","isString","isNumber","isObject","isBoolean","isPlainObject","Symbol","toStringTag","iterator","isDate","isFile","isBlob","isFileList","isStream","pipe","isFormData","kind","FormData","append","isURLSearchParams","map","isReadableStream","isRequest","isResponse","isHeaders","trim","replace","forEach","obj","fn","allOwnKeys","i","l","length","keys","getOwnPropertyNames","len","key","findKey","_key","_global","globalThis","self","window","global","isContextDefined","context","merge","caseless","assignValue","targetKey","arguments","extend","a","b","thisArg","stripBOM","content","charCodeAt","inherits","superConstructor","props","descriptors","defineProperty","value","assign","toFlatObject","sourceObj","destObj","filter","propFilter","prop","merged","endsWith","searchString","position","String","undefined","lastIndex","indexOf","toArray","arr","isTypedArray","TypedArray","Uint8Array","forEachEntry","generator","next","done","pair","matchAll","regExp","matches","exec","push","isHTMLForm","toCamelCase","replacer","m","p1","p2","toUpperCase","hasOwnProperty","isRegExp","reduceDescriptors","reducer","getOwnPropertyDescriptors","reducedDescriptors","descriptor","name","ret","defineProperties","freezeMethods","enumerable","writable","set","Error","toObjectSet","arrayOrString","delimiter","define","split","noop","toFiniteNumber","defaultValue","Number","isFinite","ALPHA","DIGIT","ALPHABET","ALPHA_DIGIT","generateString","size","alphabet","Math","random","isSpecCompliantForm","toJSONObject","stack","visit","source","target","reducedValue","isAsyncFn","isThenable","then","catch","hasOwnProp"],"mappings":"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","sourcesContent":["'use strict';\n\nimport bind from './helpers/bind.js';\n\n// utils is a library of generic helper functions non-specific to axios\n\nconst {toString} = Object.prototype;\nconst {getPrototypeOf} = Object;\n\nconst kindOf = (cache => thing => {\n    const str = toString.call(thing);\n    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type) => {\n  type = type.toLowerCase();\n  return (thing) => kindOf(thing) === type\n}\n\nconst typeOfTest = type => thing => typeof thing === type;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n *\n * @returns {boolean} True if value is an Array, otherwise false\n */\nconst {isArray} = Array;\n\n/**\n * Determine if a value is undefined\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nconst isUndefined = typeOfTest('undefined');\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nconst isArrayBuffer = kindOfTest('ArrayBuffer');\n\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  let result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a String, otherwise false\n */\nconst isString = typeOfTest('string');\n\n/**\n * Determine if a value is a Function\n *\n * @param {*} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nconst isFunction = typeOfTest('function');\n\n/**\n * Determine if a value is a Number\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Number, otherwise false\n */\nconst isNumber = typeOfTest('number');\n\n/**\n * Determine if a value is an Object\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an Object, otherwise false\n */\nconst isObject = (thing) => thing !== null && typeof thing === 'object';\n\n/**\n * Determine if a value is a Boolean\n *\n * @param {*} thing The value to test\n * @returns {boolean} True if value is a Boolean, otherwise false\n */\nconst isBoolean = thing => thing === true || thing === false;\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a plain Object, otherwise false\n */\nconst isPlainObject = (val) => {\n  if (kindOf(val) !== 'object') {\n    return false;\n  }\n\n  const prototype = getPrototypeOf(val);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Date, otherwise false\n */\nconst isDate = kindOfTest('Date');\n\n/**\n * Determine if a value is a File\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFile = kindOfTest('File');\n\n/**\n * Determine if a value is a Blob\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nconst isBlob = kindOfTest('Blob');\n\n/**\n * Determine if a value is a FileList\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a File, otherwise false\n */\nconst isFileList = kindOfTest('FileList');\n\n/**\n * Determine if a value is a Stream\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nconst isStream = (val) => isObject(val) && isFunction(val.pipe);\n\n/**\n * Determine if a value is a FormData\n *\n * @param {*} thing The value to test\n *\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nconst isFormData = (thing) => {\n  let kind;\n  return thing && (\n    (typeof FormData === 'function' && thing instanceof FormData) || (\n      isFunction(thing.append) && (\n        (kind = kindOf(thing)) === 'formdata' ||\n        // detect form-data instance\n        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')\n      )\n    )\n  )\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nconst isURLSearchParams = kindOfTest('URLSearchParams');\n\nconst [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n *\n * @returns {String} The String freed of excess whitespace\n */\nconst trim = (str) => str.trim ?\n  str.trim() : str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n *\n * @param {Boolean} [allOwnKeys = false]\n * @returns {any}\n */\nfunction forEach(obj, fn, {allOwnKeys = false} = {}) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  let i;\n  let l;\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);\n    const len = keys.length;\n    let key;\n\n    for (i = 0; i < len; i++) {\n      key = keys[i];\n      fn.call(null, obj[key], key, obj);\n    }\n  }\n}\n\nfunction findKey(obj, key) {\n  key = key.toLowerCase();\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let _key;\n  while (i-- > 0) {\n    _key = keys[i];\n    if (key === _key.toLowerCase()) {\n      return _key;\n    }\n  }\n  return null;\n}\n\nconst _global = (() => {\n  /*eslint no-undef:0*/\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  return typeof self !== \"undefined\" ? self : (typeof window !== 'undefined' ? window : global)\n})();\n\nconst isContextDefined = (context) => !isUndefined(context) && context !== _global;\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n *\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  const {caseless} = isContextDefined(this) && this || {};\n  const result = {};\n  const assignValue = (val, key) => {\n    const targetKey = caseless && findKey(result, key) || key;\n    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {\n      result[targetKey] = merge(result[targetKey], val);\n    } else if (isPlainObject(val)) {\n      result[targetKey] = merge({}, val);\n    } else if (isArray(val)) {\n      result[targetKey] = val.slice();\n    } else {\n      result[targetKey] = val;\n    }\n  }\n\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    arguments[i] && forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n *\n * @param {Boolean} [allOwnKeys]\n * @returns {Object} The resulting value of object a\n */\nconst extend = (a, b, thisArg, {allOwnKeys}= {}) => {\n  forEach(b, (val, key) => {\n    if (thisArg && isFunction(val)) {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  }, {allOwnKeys});\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n *\n * @returns {string} content value without BOM\n */\nconst stripBOM = (content) => {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n/**\n * Inherit the prototype methods from one constructor into another\n * @param {function} constructor\n * @param {function} superConstructor\n * @param {object} [props]\n * @param {object} [descriptors]\n *\n * @returns {void}\n */\nconst inherits = (constructor, superConstructor, props, descriptors) => {\n  constructor.prototype = Object.create(superConstructor.prototype, descriptors);\n  constructor.prototype.constructor = constructor;\n  Object.defineProperty(constructor, 'super', {\n    value: superConstructor.prototype\n  });\n  props && Object.assign(constructor.prototype, props);\n}\n\n/**\n * Resolve object with deep prototype chain to a flat object\n * @param {Object} sourceObj source object\n * @param {Object} [destObj]\n * @param {Function|Boolean} [filter]\n * @param {Function} [propFilter]\n *\n * @returns {Object}\n */\nconst toFlatObject = (sourceObj, destObj, filter, propFilter) => {\n  let props;\n  let i;\n  let prop;\n  const merged = {};\n\n  destObj = destObj || {};\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  if (sourceObj == null) return destObj;\n\n  do {\n    props = Object.getOwnPropertyNames(sourceObj);\n    i = props.length;\n    while (i-- > 0) {\n      prop = props[i];\n      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {\n        destObj[prop] = sourceObj[prop];\n        merged[prop] = true;\n      }\n    }\n    sourceObj = filter !== false && getPrototypeOf(sourceObj);\n  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);\n\n  return destObj;\n}\n\n/**\n * Determines whether a string ends with the characters of a specified string\n *\n * @param {String} str\n * @param {String} searchString\n * @param {Number} [position= 0]\n *\n * @returns {boolean}\n */\nconst endsWith = (str, searchString, position) => {\n  str = String(str);\n  if (position === undefined || position > str.length) {\n    position = str.length;\n  }\n  position -= searchString.length;\n  const lastIndex = str.indexOf(searchString, position);\n  return lastIndex !== -1 && lastIndex === position;\n}\n\n\n/**\n * Returns new array from array like object or null if failed\n *\n * @param {*} [thing]\n *\n * @returns {?Array}\n */\nconst toArray = (thing) => {\n  if (!thing) return null;\n  if (isArray(thing)) return thing;\n  let i = thing.length;\n  if (!isNumber(i)) return null;\n  const arr = new Array(i);\n  while (i-- > 0) {\n    arr[i] = thing[i];\n  }\n  return arr;\n}\n\n/**\n * Checking if the Uint8Array exists and if it does, it returns a function that checks if the\n * thing passed in is an instance of Uint8Array\n *\n * @param {TypedArray}\n *\n * @returns {Array}\n */\n// eslint-disable-next-line func-names\nconst isTypedArray = (TypedArray => {\n  // eslint-disable-next-line func-names\n  return thing => {\n    return TypedArray && thing instanceof TypedArray;\n  };\n})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));\n\n/**\n * For each entry in the object, call the function with the key and value.\n *\n * @param {Object<any, any>} obj - The object to iterate over.\n * @param {Function} fn - The function to call for each entry.\n *\n * @returns {void}\n */\nconst forEachEntry = (obj, fn) => {\n  const generator = obj && obj[Symbol.iterator];\n\n  const iterator = generator.call(obj);\n\n  let result;\n\n  while ((result = iterator.next()) && !result.done) {\n    const pair = result.value;\n    fn.call(obj, pair[0], pair[1]);\n  }\n}\n\n/**\n * It takes a regular expression and a string, and returns an array of all the matches\n *\n * @param {string} regExp - The regular expression to match against.\n * @param {string} str - The string to search.\n *\n * @returns {Array<boolean>}\n */\nconst matchAll = (regExp, str) => {\n  let matches;\n  const arr = [];\n\n  while ((matches = regExp.exec(str)) !== null) {\n    arr.push(matches);\n  }\n\n  return arr;\n}\n\n/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */\nconst isHTMLForm = kindOfTest('HTMLFormElement');\n\nconst toCamelCase = str => {\n  return str.toLowerCase().replace(/[-_\\s]([a-z\\d])(\\w*)/g,\n    function replacer(m, p1, p2) {\n      return p1.toUpperCase() + p2;\n    }\n  );\n};\n\n/* Creating a function that will check if an object has a property. */\nconst hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);\n\n/**\n * Determine if a value is a RegExp object\n *\n * @param {*} val The value to test\n *\n * @returns {boolean} True if value is a RegExp object, otherwise false\n */\nconst isRegExp = kindOfTest('RegExp');\n\nconst reduceDescriptors = (obj, reducer) => {\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  const reducedDescriptors = {};\n\n  forEach(descriptors, (descriptor, name) => {\n    let ret;\n    if ((ret = reducer(descriptor, name, obj)) !== false) {\n      reducedDescriptors[name] = ret || descriptor;\n    }\n  });\n\n  Object.defineProperties(obj, reducedDescriptors);\n}\n\n/**\n * Makes all methods read-only\n * @param {Object} obj\n */\n\nconst freezeMethods = (obj) => {\n  reduceDescriptors(obj, (descriptor, name) => {\n    // skip restricted props in strict mode\n    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {\n      return false;\n    }\n\n    const value = obj[name];\n\n    if (!isFunction(value)) return;\n\n    descriptor.enumerable = false;\n\n    if ('writable' in descriptor) {\n      descriptor.writable = false;\n      return;\n    }\n\n    if (!descriptor.set) {\n      descriptor.set = () => {\n        throw Error('Can not rewrite read-only method \\'' + name + '\\'');\n      };\n    }\n  });\n}\n\nconst toObjectSet = (arrayOrString, delimiter) => {\n  const obj = {};\n\n  const define = (arr) => {\n    arr.forEach(value => {\n      obj[value] = true;\n    });\n  }\n\n  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));\n\n  return obj;\n}\n\nconst noop = () => {}\n\nconst toFiniteNumber = (value, defaultValue) => {\n  return value != null && Number.isFinite(value = +value) ? value : defaultValue;\n}\n\nconst ALPHA = 'abcdefghijklmnopqrstuvwxyz'\n\nconst DIGIT = '0123456789';\n\nconst ALPHABET = {\n  DIGIT,\n  ALPHA,\n  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT\n}\n\nconst generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {\n  let str = '';\n  const {length} = alphabet;\n  while (size--) {\n    str += alphabet[Math.random() * length|0]\n  }\n\n  return str;\n}\n\n/**\n * If the thing is a FormData object, return true, otherwise return false.\n *\n * @param {unknown} thing - The thing to check.\n *\n * @returns {boolean}\n */\nfunction isSpecCompliantForm(thing) {\n  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);\n}\n\nconst toJSONObject = (obj) => {\n  const stack = new Array(10);\n\n  const visit = (source, i) => {\n\n    if (isObject(source)) {\n      if (stack.indexOf(source) >= 0) {\n        return;\n      }\n\n      if(!('toJSON' in source)) {\n        stack[i] = source;\n        const target = isArray(source) ? [] : {};\n\n        forEach(source, (value, key) => {\n          const reducedValue = visit(value, i + 1);\n          !isUndefined(reducedValue) && (target[key] = reducedValue);\n        });\n\n        stack[i] = undefined;\n\n        return target;\n      }\n    }\n\n    return source;\n  }\n\n  return visit(obj, 0);\n}\n\nconst isAsyncFn = kindOfTest('AsyncFunction');\n\nconst isThenable = (thing) =>\n  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);\n\nexport default {\n  isArray,\n  isArrayBuffer,\n  isBuffer,\n  isFormData,\n  isArrayBufferView,\n  isString,\n  isNumber,\n  isBoolean,\n  isObject,\n  isPlainObject,\n  isReadableStream,\n  isRequest,\n  isResponse,\n  isHeaders,\n  isUndefined,\n  isDate,\n  isFile,\n  isBlob,\n  isRegExp,\n  isFunction,\n  isStream,\n  isURLSearchParams,\n  isTypedArray,\n  isFileList,\n  forEach,\n  merge,\n  extend,\n  trim,\n  stripBOM,\n  inherits,\n  toFlatObject,\n  kindOf,\n  kindOfTest,\n  endsWith,\n  toArray,\n  forEachEntry,\n  matchAll,\n  isHTMLForm,\n  hasOwnProperty,\n  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors,\n  freezeMethods,\n  toObjectSet,\n  toCamelCase,\n  noop,\n  toFiniteNumber,\n  findKey,\n  global: _global,\n  isContextDefined,\n  ALPHABET,\n  generateString,\n  isSpecCompliantForm,\n  toJSONObject,\n  isAsyncFn,\n  isThenable\n};\n"]},"metadata":{},"sourceType":"module"}